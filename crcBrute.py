#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  crc_calculate.py
#  
#  Copyright 2024 sueppchen <sueppchen@DNS>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#  
#  


def main(args):
    myDict = {0x21: 0, 0x35: 1, 0x2c: 2, 0x34: 3, 0x66: 4, 0x26: 5, 0xAC: 6, 0x24: 7,     #
              0x46: 8, 0x56: 9, 0x44:10, 0x54:11, 0x64:12, 0x6d:13, 0x4c:14, 0x6c:15,     #
              0x92:16, 0xb2:17, 0xA6:18, 0xA2:19, 0xB4:20, 0x94:21, 0x86:22, 0x96:23,     #
              0x42:24, 0x62:25, 0x2a:26, 0x6a:27, 0xb6:28, 0x36:29, 0x22:30, 0x32:31,     #// 18-1f
              0x31:32, 0xB1:33, 0x95:34, 0xB5:35, 0x91:36, 0x99:37, 0x85:38, 0x89:39,     #// 20-27 
              0xa5:40, 0xa4:41, 0x8c:42, 0x84:43, 0xa1:44, 0xa9:45, 0x8d:46, 0xad:47,     #// 28-2f
              0x9a:48, 0x8a:49, 0x5a:50, 0x4a:51, 0x49:52, 0x59:53, 0x52:54, 0x51:55,     #// 30-37
              0x25:56, 0x2d:57, 0x69:58, 0x29:59, 0x4D:60, 0x45:61, 0x61:62, 0x65:63 }    #// 38-3f
    
    reDictBE = [0x21, 0x35, 0x2c, 0x34, 0x66, 0x26, 0xac, 0x24,   # // 00-07
                0x46, 0x56, 0x44, 0x54, 0x64, 0x6d, 0x4c, 0x6c,    # // 08-0f
                0x92, 0xb2, 0xa6, 0xa2, 0xb4, 0x94, 0x86, 0x96,    # // 10-17
                0x42, 0x62, 0x2a, 0x6a, 0xb6, 0x36, 0x22, 0x32,    # // 18-1f
                0x31, 0xB1, 0x95, 0xB5, 0x91, 0x99, 0x85, 0x89,    # // 20-27
                0xa5, 0xa4, 0x8c, 0x84, 0xa1, 0xa9, 0x8d, 0xad,    # // 28-2f
                0x9a, 0x8a, 0x5a, 0x4a, 0x49, 0x59, 0x52, 0x51,    # // 30-37
                0x25, 0x2d, 0x69, 0x29, 0x4D, 0x45, 0x61, 0x65]    # // 38-3f

    reDictLE = [0x84, 0xac, 0x34, 0x2c, 0x66, 0x64, 0x35, 0x24,    #
                0x62, 0x6a, 0x22, 0x2a, 0x26, 0xb6, 0x32, 0x36,    #
                0x49, 0x4d, 0x65, 0x45, 0x2d, 0x29, 0x61, 0x69,    #
                0x42, 0x46, 0x54, 0x56, 0x6d, 0x6c, 0x44, 0x4c,    #
                0x8c, 0x8d, 0xa9, 0xad, 0x89, 0x99, 0xa1, 0x91,    #
                0xa5, 0x25, 0x31, 0x21, 0x85, 0x95, 0xb1, 0xb5,    #
                0x59, 0x51, 0x5a, 0x52, 0x92, 0x9a, 0x4a, 0x8a,    #
                0xa4, 0xb4, 0x96, 0x94, 0xb2, 0xa2, 0x86, 0xa6]    #

   

    doublelist =[
                [[0x00, 0x00, 0x2f, 0x2a, 0x2f, 0x10, 0x13, 0x00, 0x25], [0x00, 0x00, 0x0E, 0x00, 0x0A, 0x08, 0x12, 0x00, 0x25]],
                [[0x01, 0x00, 0x3e, 0x00, 0x00, 0x10, 0x13, 0x00, 0x0c], [0x01, 0x00, 0x10, 0x00, 0x21, 0x08, 0x12, 0x00, 0x0C]],
                [[0x01, 0x00, 0x2f, 0x0d, 0x2f, 0x10, 0x13, 0x00, 0x24], [0x01, 0x00, 0x08, 0x00, 0x00, 0x10, 0x13, 0x00, 0x24]],
                [[0x02, 0x00, 0x2f, 0x0b, 0x2f, 0x10, 0x13, 0x00, 0x2d], [0x02, 0x00, 0x2f, 0x2f, 0x2f, 0x11, 0x25, 0x00, 0x2d]],
                [[0x0a, 0x00, 0x00, 0x00, 0x24, 0x10, 0x13, 0x00, 0x37], [0x0A, 0x00, 0x34, 0x00, 0x0A, 0x08, 0x12, 0x00, 0x37]],
                [[0x0b, 0x00, 0x2f, 0x2d, 0x2f, 0x10, 0x13, 0x00, 0x10], [0x0b, 0x00, 0x2f, 0x2f, 0x2f, 0x11, 0x0e, 0x00, 0x10]],
                [[0x19, 0x00, 0x00, 0x3f, 0x00, 0x10, 0x13, 0x00, 0x32], [0x19, 0x00, 0x10, 0x00, 0x09, 0x08, 0x12, 0x00, 0x32]],
                [[0x1b, 0x00, 0x00, 0x15, 0x00, 0x10, 0x13, 0x00, 0x3b], [0x1b, 0x00, 0x00, 0x00, 0x0b, 0x10, 0x13, 0x00, 0x3b]],
                [[0x23, 0x00, 0x2E, 0x00, 0x0A, 0x08, 0x12, 0x00, 0x1F], [0x23, 0x00, 0x10, 0x00, 0x37, 0x08, 0x12, 0x00, 0x1F]],
                [[0x28, 0x00, 0x00, 0x0b, 0x00, 0x10, 0x13, 0x00, 0x1c], [0x28, 0x00, 0x15, 0x00, 0x00, 0x10, 0x13, 0x00, 0x1c]],
                [[0x2a, 0x00, 0x2f, 0x2f, 0x2f, 0x32, 0x11, 0x00, 0x2e], [0x2A, 0x00, 0x10, 0x00, 0x27, 0x08, 0x12, 0x00, 0x2E]],
                [[0x2c, 0x00, 0x00, 0x06, 0x00, 0x10, 0x13, 0x00, 0x3a], [0x2c, 0x00, 0x2f, 0x2f, 0x2f, 0x12, 0x11, 0x00, 0x3a]],
                [[0x32, 0x00, 0x2f, 0x2f, 0x2f, 0x00, 0x35, 0x00, 0x14], [0x32, 0x00, 0x10, 0x00, 0x12, 0x08, 0x12, 0x00, 0x14]],
                [[0x32, 0x00, 0x38, 0x00, 0x00, 0x10, 0x13, 0x00, 0x3f], [0x32, 0x00, 0x2f, 0x2f, 0x2f, 0x00, 0x39, 0x00, 0x3f]],
                [[0x39, 0x00, 0x00, 0x00, 0x14, 0x10, 0x13, 0x00, 0x2e], [0x39, 0x00, 0x1A, 0x00, 0x0A, 0x08, 0x12, 0x00, 0x2E]],
                [[0x39, 0x00, 0x25, 0x00, 0x00, 0x10, 0x13, 0x00, 0x35], [0x39, 0x00, 0x10, 0x00, 0x23, 0x08, 0x12, 0x00, 0x35]],
                [[0x02, 0x00, 0x2f, 0x2f, 0x2f, 0x11, 0x23, 0x00, 0x34], [0x02, 0x00, 0x10, 0x33, 0x10, 0x10, 0x0A, 0x00, 0x34]],
                [[0x06, 0x00, 0x2f, 0x2f, 0x2f, 0x19, 0x11, 0x00, 0x2b], [0x06, 0x00, 0x10, 0x0D, 0x10, 0x10, 0x0A, 0x00, 0x2B]],
                [[0x07, 0x00, 0x2f, 0x2f, 0x2f, 0x11, 0x2e, 0x00, 0x2b], [0x07, 0x00, 0x10, 0x28, 0x10, 0x10, 0x0A, 0x00, 0x2B]],
                [[0x08, 0x00, 0x10, 0x37, 0x10, 0x10, 0x0A, 0x00, 0x07], [0x08, 0x00, 0x04, 0x20, 0x10, 0x08, 0x12, 0x00, 0x07]],
                [[0x2f, 0x00, 0x00, 0x33, 0x00, 0x10, 0x13, 0x00, 0x0a], [0x2F, 0x00, 0x01, 0x20, 0x10, 0x08, 0x12, 0x00, 0x0A]],
                [[0x39, 0x00, 0x2f, 0x2f, 0x2f, 0x00, 0x33, 0x00, 0x2b], [0x39, 0x00, 0x10, 0x1F, 0x10, 0x10, 0x0A, 0x00, 0x2B]],
                [[0x3B, 0x00, 0x10, 0x00, 0x2B, 0x08, 0x12, 0x00, 0x26], [0x3B, 0x00, 0x03, 0x20, 0x10, 0x08, 0x12, 0x00, 0x26]],
                [[0x3d, 0x00, 0x20, 0x00, 0x00, 0x10, 0x13, 0x00, 0x30], [0x3D, 0x00, 0x10, 0x21, 0x10, 0x10, 0x0A, 0x00, 0x30]],
                [[0x3f, 0x00, 0x2f, 0x2f, 0x2f, 0x02, 0x11, 0x00, 0x11], [0x3F, 0x00, 0x12, 0x20, 0x10, 0x08, 0x12, 0x00, 0x11]],
                ]  #


    

    polyZoo12 = [0x61e, 0x987, 0xa33, 0x829, 0xddf, 0xbdf, 0x83e, 0xb75,
                 0x8f3, 0xf89, 0x817, 0xc07, 0xbff, 0xb41, 0xb91, 0xe98,
                 0xc05, 0x993, 0xa6f, 0xc06, 0xbae, 0x8f8, 0xa4f]

     
    def printByte(helper):
        print("0b", end="")
        bit7= (helper>>7) & 0x01
        bit6= (helper>>6) & 0x01
        bit5= (helper>>5) & 0x01
        bit4= (helper>>4) & 0x01
        bit3= (helper>>3) & 0x01
        bit2= (helper>>2) & 0x01
        bit1= (helper>>1) & 0x01
        bit0= (helper>>0) & 0x01
        print(str(bit5)+str(bit4)+str(bit3)+str(bit2)+str(bit1)+str(bit0), end="")

    import numpy as np

    def reflect_data(x, width):
        # See: https://stackoverflow.com/a/20918545
        if width == 8:
            x = ((x & 0x55) << 1) | ((x & 0xAA) >> 1)
            x = ((x & 0x33) << 2) | ((x & 0xCC) >> 2)
            x = ((x & 0x0F) << 4) | ((x & 0xF0) >> 4)
        elif width == 12:
            x = ((x & 0x555) << 1) | ((x & 0xAAA) >> 1)
            x = ((x & 0x333) << 2) | ((x & 0xCCC) >> 2)
            x = ((x & 0x00F) << 8) | ((x & 0xF00) >> 8) | (x & 0x0F0)
        elif width == 16:
            x = ((x & 0x5555) << 1) | ((x & 0xAAAA) >> 1)
            x = ((x & 0x3333) << 2) | ((x & 0xCCCC) >> 2)
            x = ((x & 0x0F0F) << 4) | ((x & 0xF0F0) >> 4)
            x = ((x & 0x00FF) << 8) | ((x & 0xFF00) >> 8)
        elif width == 32:
            x = ((x & 0x55555555) << 1) | ((x & 0xAAAAAAAA) >> 1)
            x = ((x & 0x33333333) << 2) | ((x & 0xCCCCCCCC) >> 2)
            x = ((x & 0x0F0F0F0F) << 4) | ((x & 0xF0F0F0F0) >> 4)
            x = ((x & 0x00FF00FF) << 8) | ((x & 0xFF00FF00) >> 8)
            x = ((x & 0x0000FFFF) << 16) | ((x & 0xFFFF0000) >> 16)
        else:
            raise ValueError('Unsupported width')
        return x

    def crc_poly(data, n, poly, crc=0, ref_in=False, ref_out=False, xor_out=0):
        
        g = 1 << n | poly  # Generator polynomial
            
        # Loop over the data
        for d in data:
            # Reverse the input byte if the flag is true
            if ref_in:
                d = reflect_data(d, 8)

            # XOR the top byte in the CRC with the input byte
            crc ^= d << (n - 8)

            # Loop over all the bits in the byte
            for _ in range(8):
                # Start by shifting the CRC, so we can check for the top bit
                crc <<= 1

                # XOR the CRC if the top bit is 1
                if crc & (1 << n):
                    crc ^= g

        # Reverse the output if the flag is true
        if ref_out:
            crc = reflect_data(crc, n)

        # Return the CRC value
        return crc ^ xor_out
    
#    lastCrc = 0
    bits = 16
    
    SHIFT=0b01011001   #shift 8 to 6, (6+5 transform Input), short | reflectOUT, reflectIN, (1+0 transform output)

    match = 0
    hexstring=''
    
    shifting=8
    
    helper0=0
    daten0=0
    crc0=0

    helper1=0
    daten1=0
    crc1=0
    crc16Zoo = [0x8d95, 0xfdbf, 0x8016, 0xc7ab, 0x979e, 0x9627, 0xe433, 0xc5db, 
                0xac6f, 0xb82d, 0x88f9, 0x86f2, 0x978a, 0xd175, 0x8fdb, 0xed2f, 
                0xc4bd, 0xb57d, 0xefff, 0xa001, 0x8003, 0x8810, 0x9747, 0xd04b, 
                0x808d, 0x935a, 0xa10e, 0x968b, 0xbaad, 0xd3e9, 0xd015, 0x8ee7, 
                0xcbab, 0xf94f, 0xac9a, 0xb7b1, 0xa755, 0xadc9, 0x82c4, 0x9eb2, 
                0xc86c, 0xe92f]
    startValue = [0, 0x1d0f, 0xffff]
    xorList = [0, 1, 0xaaaa, 0xffff]
    
    
    for SHIFT in range(0,0x80):
        for outFx in xorList:
            for init in startValue:
                for key in crc16Zoo:
                    match = 0
                    for touple in doublelist:
                        # hex originals

                        touple[0][0] = 0
                        touple[0][8] = 0
                        helper0=0
                        for value0 in touple[0]:
                            if(((SHIFT >> 5) & 0x3) == 1):
                                value0  = value0 << 2
                            if(((SHIFT >> 5) & 0x3) == 2):
                                value0 = reDictBE[value0]
                            if(((SHIFT >> 5) & 0x3) == 3):
                                value0 = reDictLE[value0]
                            helper0  = helper0 << shifting
                            helper0 += value0
                        
                        #print(": %012x " % helper0, end="\r\n")
                        
                        hexstring= str(hex(helper0)[2:])
                        if(len(hexstring) % 2 == 1):
                          hexstring = '0' + hexstring
                        daten0 = bytearray.fromhex(hexstring)
                        
                        touple[1][0] = 0
                        touple[1][8] = 0
                        helper1=0
                        for value1 in touple[1]:
                            #print("%02x " % value, end="")
                            if(((SHIFT >> 5) & 0x3) == 1):
                                value1  = value1 << 2
                            if(((SHIFT >> 5) & 0x3) == 2):
                                value1 = reDictBE[value1]
                            if(((SHIFT >> 5) & 0x3) == 3):
                                value1 = reDictLE[value1]
                            helper1  = helper1 << shifting
                            helper1 += value1
                        #print(": %012x " % helper1, end="\r\n")
                        hexstring= str(hex(helper1)[2:])
                        if(len(hexstring) % 2 == 1):
                          hexstring = '0' + hexstring
                        daten1 = bytearray.fromhex(hexstring)
                
                        if(SHIFT & 0x10):                              #short
                            daten0 = daten0[1:][:7]       
                            daten1 = daten1[1:][:7]       

                        crc0 = crc_poly(daten0, bits, key, crc=init, ref_in=(SHIFT & 0x4), ref_out=(SHIFT & 0x8), xor_out=outFx)
                        crc1 = crc_poly(daten1, bits, key, crc=init, ref_in=(SHIFT & 0x4), ref_out=(SHIFT & 0x8), xor_out=outFx)
                        
                        if(bits>12 and ((SHIFT & 0x3) == 0)):
                            crc0=crc0>>(bits-12)
                            crc1=crc1>>(bits-12)
                            
                        if(bits>12 and ((SHIFT & 0x3) == 1)):
                            helperH = ((crc0 >> 10) & 0x3F) 
                            helperL = ((crc0 >> 2) & 0x3F)
                            crc0 =  (helperH << 6) + helperL
                            helperH = ((crc1 >> 10) & 0x3F) 
                            helperL = ((crc1 >> 2) & 0x3F)
                            crc1 =  (helperH << 6) + helperL

                        if(bits>12 and ((SHIFT & 0x3) == 2)):
                            crc0 &= 0xfff
                            crc1 &= 0xfff

                        if(bits>12 and ((SHIFT & 0x3) == 3)):
                            helperH = ((crc0 >> 8) & 0x3F) 
                            helperL = (crc0 & 0x3F)
                            crc0 =  (helperH << 6) + helperL
                            helperH = ((crc1 >> 8) & 0x3F) 
                            helperL = (crc1 & 0x3F)
                            crc1 =  (helperH << 6) + helperL
                                        
                        #print("%03x "  % crc0, end="")
                        #print("%03x "  % crc1, end="")
                        #print("%03x "  % crc2, end="")
                        #print("%03x "  % crc3, end="\r\n")
                        
                        if((crc0 == crc1) and (crc0 != 0)):
                            match += 1
                            if(match > 5):
                                print("Shift: %03x " % SHIFT, end="")
                                print("FX: %03x " % outFx, end="")
                                print("Init: %03x " % init, end="")
                                print("key: %03x " % key, end="")
                                #print("%03x "  % crc0, end="")
                                print("match!", end="")
                                print(" ")


    return 0
 
    
if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))
